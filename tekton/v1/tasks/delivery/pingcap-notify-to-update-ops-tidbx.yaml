# yaml-language-server: $schema=https://github.com/redhat-developer/vscode-tekton/raw/refs/heads/main/scheme/tekton.dev/v1_Task.json
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: pingcap-notify-to-update-ops-tidbx
  labels:
    app.kubernetes.io/version: "0.1.0"
  annotations:
    tekton.dev/pipelines.minVersion: "1.0.0"
    tekton.dev/categories: delivery
    tekton.dev/tags: ops,cloud,tidbx
    tekton.dev/displayName: "Notify to update ops config for TiDB-X"
    tekton.dev/platforms: "linux/amd64,linux/arm64"
spec:
  params:
    - name: images
      type: string
      description: images list
    - name: target_images
      type: string
      description: delivered target images list
      default: "[]"
    - name: stage
      type: string
      description: stage name
  workspaces:
    - name: notify-config
      description: |
        Configuration for GitHub authentication and issue URLs.
        Include files:
        - GitHub token: <stage>_github_token
        - GitHub issue URL: <stage>_github_issue_url
      readOnly: true
    - name: ops-config
      description: |
        Configuration to call Ops platform APIs.
        Include files:
        - <stage>.json
      readOnly: true
  stepTemplate:
    image: ghcr.io/pingcap-qe/cd/utils/release:v2025.10.26-5-ge8130cb
  steps:
    - name: update-ops-config
      when:
        - input: "$(params.stage)"
          operator: in
          values: ["prod"]
      args: ["$(params.stage)", "$(params.images)", "/workspace/ops-tickets.txt"]
      script: |
        #!/usr/bin/env bash
        set -euo pipefail

        function get_ops_instance_url() {
            local stage="$1"
            local instance_id="$2"

            if [ "$stage" = "prod" ]; then
                echo "https://ops.tidbcloud.com/operations/$instance_id"
            else
                echo "https://ops-${stage}.tidbcloud.com/operations/$instance_id"
            fi
        }

        function make_ops_api_call() {
            local stage="$1"
            local component="$2"
            local component_version="$3"
            local cluster_type="$4"
            local image_repo="$5"
            local image_tag="$6"
            local api_base_url="$7"
            local api_key="$8"
            local save_file="$9"

            local api_url="$api_base_url/$component"

            # prepare payload file
            local payload_file="/tmp/$component-$component_version.json"
            jq -n \
              --arg cluster_type "$cluster_type" \
              --arg version "$component_version" \
              --arg base_image "$image_repo" \
              --arg tag "$image_tag" \
              '{"cluster_type": $cluster_type, "version": $version, "base_image": $base_image, "tag": $tag, "policy": "immediate"}' > $payload_file

            echo "ðŸš€ Request to update the image for component $component@$component_version in stage $stage with: $image_repo:$image_tag"
            local response_file="/tmp/${component}-${component_version}-response.json"
            curl -f \
              --request POST \
              --location "$api_url" \
              --header "x-api-key: $api_key" \
              --header "Content-Type: application/json" \
              --data "@$payload_file" \
              --output "$response_file"
            ops_instance_id=$(jq -r .instance_id $response_file)
            ops_ticket_url="$(get_ops_instance_url $stage $ops_instance_id)"
            echo "âœ… Requested image updating successfully for component $component@$component_version in stage $stage with: $image_repo:$image_tag, the Ops ticket URL is: $ops_ticket_url"
            echo "$component@$component_version in $stage stage: $ops_ticket_url" >> "$save_file"
        }

        function update_ops_config_for_image() {
          local stage="$1"
          local image="$2"
          local stage_config_file="$3"
          local save_file="$4"
          local api_base_url="$(jq -r '.api_base_url' $stage_config_file)"
          local api_key="$(jq -r '.api_key' $stage_config_file)"

          # split image name and tag
          local image_repo=${image%:*}
          local image_tag=${image##*:}

          # get the component name from image repo: the base name of the image repo
          local components=$(jq -r --arg img "$image_repo" '.components | to_entries | map(select(.value.base_image==$img) | .key) | join(",")' $stage_config_file)
          if [ -z "$components" ]; then
            echo "ðŸ¤· No component matched to bump on the Ops platform, skip."
            return 0
          fi

          # get the component version from image tag(should return the vX.Y.Z part)
          local component_version=$(echo $image_tag | cut -d'-' -f1)

          # loop the components
          IFS=',' read -ra components_array <<< "$components"
          for component in "${components_array[@]}"; do
            cluster_type="$(jq -r ".components.${component}.cluster_type" $stage_config_file)"
            make_ops_api_call "$stage" "$component" "$component_version" "$cluster_type" "$image_repo" "$image_tag" "$api_base_url" "$api_key" "$save_file"
          done
        }

        function main() {
          stage="$1"
          stage_config_file=$(workspaces.ops-config.path)/${stage}.json
          images="$(echo "$2" | jq -r '.[]')"
          save_file="$3"
          for image in $images; do
            update_ops_config_for_image "$stage" "$image" "$stage_config_file" "$save_file"
          done

          echo "ðŸŽ‰ Done!"
        }

        main "$@"

    - name: notify-in-lark-channel
      args: ["$(params.stage)", "$(params.images)", "$(params.target_images)", "/workspace/ops-tickets.txt"]
      script: |
        #!/usr/bin/env bash
        set -euo pipefail

        function send_lark_notification() {
          local message="$1"
          local lark_webhook_url="$2"
          local body_file=$(mktemp)

          # Create JSON payload
          jq -n --arg text "$message" '{ msg_type: "text", content: { text: $text } }' > "$body_file"

          # Send notification
          curl --fail -X POST -H "Content-Type: application/json" -d "@$body_file" "$lark_webhook_url"

          # Clean up
          rm -f "$body_file"
        }

        function generate_image_delivery_message() {
          local stage="$1"
          local source_images="$2"
          local target_images="$3"

          local title="The Images are delivered to cloud registries of ${stage} env."
          local source_image_lines="$(echo "$source_images" | jq -r '.[]')"
          local target_image_lines="$(echo "$target_images" | jq -r '.[]')"
          printf "%s\nSources:\n%s\nTargets:\n%s" "$title" "$source_image_lines" "$target_image_lines"
        }

        function generate_ops_tickets_message() {
          local stage="$1"
          local tickets_file="$2"

          local message="The Ops tickets are created for ${stage} env:\n"
          message+="$(cat "$tickets_file")"
          echo "$message"
        }

        # Main execution
        lark_webhook_url="$(cat $(workspaces.notify-config.path)/${1}_lark_webhook)"

        # Send image delivery notification
        image_delivery_message="$(generate_image_delivery_message "$1" "$2" "$3")"
        send_lark_notification "$image_delivery_message" "$lark_webhook_url"

        # Send ops tickets notification if tickets file exists
        if [ -f "$4" ]; then
          ops_tickets_message="$(generate_ops_tickets_message "$1" "$4")"
          send_lark_notification "$ops_tickets_message" "$lark_webhook_url"
        fi
