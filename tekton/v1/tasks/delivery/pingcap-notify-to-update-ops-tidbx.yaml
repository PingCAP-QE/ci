# yaml-language-server: $schema=https://github.com/redhat-developer/vscode-tekton/raw/refs/heads/main/scheme/tekton.dev/v1_Task.json
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: pingcap-notify-to-update-ops-tidbx
  labels:
    app.kubernetes.io/version: "0.1.0"
  annotations:
    tekton.dev/pipelines.minVersion: "1.0.0"
    tekton.dev/categories: delivery
    tekton.dev/tags: ops,cloud,tidbx
    tekton.dev/displayName: "Notify to update ops config for TiDB-X"
    tekton.dev/platforms: "linux/amd64,linux/arm64"
spec:
  params:
    - name: images
      type: string
      description: images list
    - name: stage
      type: string
      description: stage name
  workspaces:
    - name: notify-config
      description: |
        Configuration for GitHub authentication and issue URLs.
        Include files:
        - GitHub token: <stage>_github_token
        - GitHub issue URL: <stage>_github_issue_url
      readOnly: true
    - name: ops-config
      description: |
        Configuration to call Ops platform APIs.
        Include files:
        - <stage>.json
      readOnly: true
  stepTemplate:
    image: ghcr.io/pingcap-qe/cd/utils/release:v2025.10.26-5-ge8130cb
  steps:
    - name: update-ops-config
      when:
        - input: "$(params.stage)"
          operator: in
          values: ["prod"]
      args:
        ["$(params.stage)", "$(params.images)", "/workspace/ops-tickets.txt"]
      script: |
        #!/usr/bin/env bash
        set -euo pipefail

        function get_ops_instance_url() {
            local stage="$1"
            local instance_id="$2"

            if [ "$stage" = "prod" ]; then
                echo "https://ops.tidbcloud.com/operations/$instance_id"
            else
                echo "https://ops-${stage}.tidbcloud.com/operations/$instance_id"
            fi
        }

        function make_ops_api_call() {
            local stage="$1"
            local component="$2"
            local component_version="$3"
            local cluster_type="$4"
            local image_repo="$5"
            local image_tag="$6"
            local api_base_url="$7"
            local api_key="$8"
            local save_file="$9"

            local api_url="$api_base_url/$component"

            # prepare payload file
            local payload_file="/tmp/$component-$component_version.json"
            jq -n \
              --arg cluster_type "$cluster_type" \
              --arg version "$component_version" \
              --arg base_image "$image_repo" \
              --arg tag "$image_tag" \
              '{"cluster_type": $cluster_type, "version": $component_version, "base_image": $base_image, "tag": $tag, "policy": "immediate"}' > $payload_file

            echo "ðŸš€ Request to update the image for component $component@$component_version in stage $stage with: $image_repo:$image_tag"
            local response_file="/tmp/${component}-${component_version}-response.json"
            curl -f \
              --request POST \
              --location "$api_url" \
              --header "x-api-key: $api_key" \
              --header "Content-Type: application/json" \
              --data "@$payload_file" \
              --output "$response_file"
            ops_instance_id=$(jq -r .instance_id $response_file)
            ops_ticket_url="$(get_ops_instance_url $stage $ops_instance_id)"
            echo "âœ… Requested image updating successfully for component $component@$component_version in stage $stage with: $image_repo:$image_tag, the Ops ticket URL is: $ops_ticket_url"

            echo "$ops_ticket_url" >> "$save_file"
        }

        function update_ops_config_for_image() {
          local stage="$1"
          local image="$2"
          local stage_config_file="$3"
          local save_file="$4"
          local api_base_url="$(jq -r '.api_base_url' $stage_config_file)"
          local api_key="$(jq -r '.api_key' $stage_config_file)"

          # split image name and tag
          local image_repo=${image%:*}
          local image_tag=${image##*:}

          # get the component name from image repo: the base name of the image repo
          local components=$(jq -r --arg img "$image_repo" '.components | to_entries | map(select(.value.base_image==$img) | .key) | join(",")' $stage_config_file)
          if [ -z "$components" ]; then
            echo "ðŸ¤· No component matched to bump on the Ops platform, skip."
            return 0
          fi

          # get the component version from image tag(should return the vX.Y.Z part)
          local component_version=$(echo $image_tag | cut -d'-' -f1)

          # loop the components
          IFS=',' read -ra components_array <<< "$components"
          for component in "${components_array[@]}"; do
            cluster_type="$(jq -r ".components.${component}.cluster_type" $stage_config_file)"
            make_ops_api_call "$stage" "$component" "$component_version" "$cluster_type" "$image_repo" "$image_tag" "$api_base_url" "$api_key" "$save_file"
          done
        }

        function main() {
          stage="$1"
          stage_config_file=$(workspaces.ops-config.path)/${stage}.json
          images="$(echo "$2" | jq -r '.[]')"
          save_file="$3"
          for image in $images; do
            update_ops_config_for_image "$stage" "$image" "$stage_config_file" "$save_file"
          done

          echo "ðŸŽ‰ Done!"
        }

        main "$@"

    - name: notify-in-lark-channel
      args:
        ["$(params.stage)", "$(params.images)", "/workspace/ops-tickets.txt"]
      script: |
        #!/usr/bin/env bash
        set -euo pipefail

        function notify_in_lark_channel() {
          local content="$1"
          local lark_webhook_url="$2"

          printf "%s" "$content" > content.txt
          body_file=/workspace/lark-notify.json
          yq -n --output-format json '.msg_type = "text"' > $body_file
          yq --output-format json -i '.content.text = load_str("content.txt")' $body_file

          # send lark message.
          curl --fail -X POST -H 'Content-Type: application/json' -d "@$body_file" "$lark_webhook_url"
          rm -f content.txt $body_file
        }

        lark_webhook_url="$(cat $(workspaces.notify-config.path)/${1}_lark_webhook)"

        # update image delivery results
        content="$(printf "The Images are delivered to cloud registries of %s env:\n%s" "$1" "$(echo "$2" | jq -r '.[]')")"
        notify_in_lark_channel "$content" "$lark_webhook_url"

        # update ops ticket create results
        if [ -f "$3" ]; then
          content="$(printf "The Ops tickets are created for %s env:\n%s" "$1" "$(cat $3)")"
          notify_in_lark_channel "$content" "$lark_webhook_url"
        fi
