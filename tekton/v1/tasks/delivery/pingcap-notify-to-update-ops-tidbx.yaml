# yaml-language-server: $schema=https://github.com/redhat-developer/vscode-tekton/raw/refs/heads/main/scheme/tekton.dev/v1_Task.json
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: pingcap-notify-to-update-ops-tidbx
  labels:
    app.kubernetes.io/version: "0.1.0"
  annotations:
    tekton.dev/pipelines.minVersion: "1.0.0"
    tekton.dev/categories: delivery
    tekton.dev/tags: ops,cloud,tidbx
    tekton.dev/displayName: "Notify to update ops config for TiDB-X"
    tekton.dev/platforms: "linux/amd64,linux/arm64"
spec:
  params:
    - name: images
      type: string
      description: images list
    - name: stage
      type: string
      description: stage name
  workspaces:
    - name: notify-config
      description: |
        Configuration for GitHub authentication and issue URLs.
        Include files:
        - GitHub token: <stage>_github_token
        - GitHub issue URL: <stage>_github_issue_url
      readOnly: true
    - name: ops-config
      description: |
        Configuration to call Ops platform APIs.
        Include files:
        - <stage>.json
      readOnly: true
  stepTemplate:
    image: ghcr.io/pingcap-qe/cd/utils/release:v2025.10.26-5-ge8130cb
  steps:
    - name: notify-in-lark-channel
      args: ["$(params.stage)", "$(params.images)"]
      script: |
        #!/usr/bin/env bash
        set -e

        function notify_image_in_lark_channel() {
          local stage="$1"
          local image="$2"
          local lark_webhook_url="$3"

          # prepare lark message.
          echo "The Image is delivered to cloud registries of $stage env:" | tee content.txt
          echo "  ${image}" | tee -a content.txt
          body_file=/workspace/lark-notify.json
          yq -n --output-format json '.msg_type = "text"' > $body_file
          yq --output-format json -i '.content.text = load_str("content.txt")' $body_file

          # send lark message.
          curl --fail -X POST -H 'Content-Type: application/json' -d "@$body_file" "$lark_webhook_url"
          rm -f content.txt $body_file
        }

        stage="$1"
        images="$(echo "$2" | jq -r '.[]')"
        lark_webhook_url="$(cat $(workspaces.notify-config.path)/${stage}_lark_webhook)"

        for image in $images; do
          notify_image_in_lark_channel "$stage" "$image" "$lark_webhook_url"
        done
    - name: update-ops-config
      when:
        - input: "$(params.stage)"
          operator: in
          values: ["prod"]
      args: ["$(params.stage)", "$(params.images)"]
      script: |
        #!/usr/bin/env bash
        set -euo pipefail

        function update_ops_config_for_image() {
          local stage="$1"
          local image="$2"
          local stage_config_file="$3"

          local api_base_url="$(jq -r '.api_base_url' $stage_config_file)"
          local api_key="$(jq -r '.api_key' $stage_config_file)"

          # split image name and tag
          local image_repo=$(echo $image | cut -d':' -f1)
          local image_tag=$(echo $image | cut -d':' -f2)

          # get the component name from image repo: the base name of the image repo
          local components=$(jq -r --arg img "$image_repo" '.components | to_entries | map(select(.value.base_image==$img) | .key) | join(",")' $stage_config_file)
          if [ -z "$components" ]; then
            echo "ðŸ¤· No component matched to bump on the Ops platform, skip."
            return 0
          fi


          # get the component version from image tag(should return the vX.Y.Z part)
          local version=$(echo $image_tag | cut -d'-' -f1)

          # loop the components
          IFS=',' read -ra components_array <<< "$components"
          for component in "${components_array[@]}"; do
            cluster_type="$(jq -r ".components.${component}.cluster_type" $stage_config_file)"
            echo "ðŸš€ Request to update the image for component $component@$version in stage $stage with: $image_repo:$image_tag"
            curl -f \
              --location "$api_base_url/$component" \
              --header "x-api-key: $api_key" \
              --header "Content-Type: application/json" \
              --data "{\"cluster_type\": \"$cluster_type\", \"version\": \"$version\", \"base_image\": \"$image_repo\", \"tag\": \"$image_tag\"}"
            echo "âœ… Requested image updating successfully"
          done
        }

        stage="$1"
        stage_config_file=$(workspaces.ops-config.path)/${stage}.json
        images="$(echo "$2" | jq -r '.[]')"
        for image in $images; do
          update_ops_config_for_image "$stage" "$image" "$stage_config_file"
        done

        echo "ðŸŽ‰ Done!"
